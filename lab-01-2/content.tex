\chapter{Функции системного таймера \newline в системах разделения времени}
В разделе рассмотрены функции обработчика прерывания от системного таймера в операционных системах семейства Windows и Unix. 
\section{Windows системы}
\subsection{Обработчик прерывания по тику}
Обработчик прерываний по тику выполняет следующие действия:
\begin{itemize}
	\item инкремент счетчика реального времени;
	\item декремент кванта текущего потока;
	\item декремент счетчика отложенных задач;
	
\end{itemize}
\subsection{Обработчик прерывания по главному тику}

Обработчик прерываний по главному тику:
\begin{itemize}
	\item ставит в очередь DPC объект диспетчера настройки баланса (диспетчер активизируется каждую секунду для возможной инициации событий, связанных с планированием и управлением памятью)
	\item возвращает системе ресурсы, задействованные объектом <<событие>>, который ожидает диспетчер настройки баланса.
\end{itemize}
 

\subsection{Обработчик прерывания по кванту}
Обработчик прерывания по кванту инициализирует диспетчеризацию потоков, то есть ставит соответствующий объект в очередь DPC.
\section{Unix системы}
\subsection{Обработчик прерывания по тику}
Обработчик прерываний по тику выполняет следующие действия:
\begin{itemize}
	\item инкремент таймеров системы --- например, количество тиков, отсчитанных с момента загрузки системы ($SVR4$, переменная $lbolt$);
	\item декремент счетчика времени до отправления на выполнение отложенных вызовов --- при достижении счетчиком нулевого значения выставление флага для обработчика отложенных вызовов; 
	\item декремент кванта текущего потока.
\end{itemize}

\subsection{Обработчик прерывания по главному тику}
Обработчик прерывания по главному тику ставит в очередь на выполнение отложенные вызовы функций, относящиеся к работе планировщика, такие как пересчет приоритетов. Также он ставит в очередь на выполнение отложенный вызов процедуры wakeup, которая перемещает дескрипторы процессов из очереди <<спящих>> в очередь <<готовых к выполнению>>.

Помимо этого, обработчик выполняет декремент счетчика времени, оставшегося до отправления одного из следующих сигналов:
\begin{itemize}
	\item SIGALARM --- сигнал тревоги реального времени, который отпарвляется по истечении заданного промежутка реального времени;
	\item SIGPROF --- сигнал профилирования таймера;
	\item SIGVTALRM --- сигнал тревоги виртуального времени, который измеряет время работы процесса в режиме задачи.
\end{itemize}
\subsection{Обработчик прерывания по кванту}
Обработчик прерывания по кванту посылает текущему процессу сигнала  SIGXCPU --- превышение лимита размера файла, если процесс израсходовал выделенный ему квант. \newline\newline

\chapter{Пересчет динамических \newline приоритетов}
Системы семейства Unix и Windows являются системами общего назначения -- это означает, что пересчитываться могут только пользовательские приоритеты. Остальные приоритеты являются статическими.
\section{Windows системы}
В системе Windows реализовано вытесняемое планирование на основе уровней приоритета, при котором выполняется готовый поток с наивысшим относительным приоритетом (базовый приоритет назначается соответствующему процессу).

Диспетчер настройки баланса сканирует очередь готовых процессов раз в секунду. Если он обнаруживает процессы, ожидающие выполнение более 4 секунд, то он повышает его приоритет и он перемещается в начало очереди, получая при этом процессорное время. Как только квант истекает, приоритет процесса снижается до базового приоритета. Если процесс не был завершен за квант времени или был вытеснен процессом с более высоким приоритетом, то после снижения приоритета процесс возвращается в очередь. 

Для минимизации расхода процессорного времени, диспетчер настройки баланса сканирует только 16 позиций в очереди. Приоритет же повышается не более чем у 10 процессов за проход. При обнаружении 10 процессов, приоритет которых надо повысить, сканирование прекращается. При следующем проходе сканирование возобновляется с того места, где оно было прервано. 

В системе предусмотрено 32 уровня приоритетов:
\begin{itemize}
	\item приоритет 31 --- наивысший приоритет;
	\item процессы реального времени имеют приоритет от 16 до 31;
	\item 0 - 15 --- динамические уровни;
	\item 0 --- зарезервирован для процесса обнуления страниц.
\end{itemize}

Звуковая карта имеет уровень приоритета выше, чем клавиатура и мышь, поскольку формирование звука --- это процесс реального времени. 

Уровни приоритета потоков назначаются с двух позиций: Windows API и ядра операционной системы. Windows API сортирует процессы по классам приоритета, которые были назначены при их создании:
\begin{itemize}
	\item реального времени (real-time, 4);
	\item высокий (high, 3);
	\item выше обычного (above normal, 6);
	\item обычный (normal, 2);
	\item ниже обычного (below normal, 5);
	\item простой (idle, 1).
\end{itemize}

API-функция SetPriorityClass позволяет изменять класс приоритета процесса до одного
из этих уровней.
Затем назначается относительный приоритет потоков процесса:
\begin{itemize}
	\item критичный по времени (time critical, 15);
	\item наивысший (highest, 2);
	\item выше обычного (above normal, 1);
	\item обычный (normal, 0);
	\item ниже обычного (below normal, -1);
	\item низший (lowest, -2);
	\item простой (idle, -15).
\end{itemize}
Соответствие между приоритетами Windows API и ядра Windows приведено в таблице:
\begin{table}[H]
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|c|}
						\hline
			~ & real-time & high & above normal & \textnormal{normal} & \textnormal{below normal} & \textnormal{idle}\\
			\hline
			\textnormal{time critical} & 31 & 15 & 15 & 15 & 15 & 15 \\
			\hline
			\textnormal{highest} & 26 & 15 & 12 & 10 & 8 & 6 \\
			\hline
			\textnormal{above normal} & 25 & 14 & 11 & 9 & 7 & 5 \\
			\hline
			\textnormal{normal} & 24 & 13 & 10 & 8 & 6 & 4 \\
			\hline
			\textnormal{below normal} & 23 & 12 & 9 & 7 & 5 & 3 \\
			\hline
			\textnormal{lowest} & 22 & 11 & 8 & 6 & 4 & 2 \\
			\hline
			\textnormal{idle} & 16 & 1 & 1 & 1 & 1 & 1 \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Текущий приоритет в динамическом диапазоне может быть повышен планировщиком по следующим причинам:
\begin{itemize}
	\item завершение операций ввода-вывода;
	\item повышение приоритета владельца блокировки;
	\item ввод из пользовательского интерфейса;
	\item длительное ожидание ресурса исполняющей системы;
	\item ожидание объекта ядра;
	\item готовый к выполнению поток не был запущен в течение длительного времени;
	\item повышение приоритета проигрывания мультимедиа службой планировщика MMCSS (см. таблицу \ref{mss}).
\end{itemize}

\begin{table}[H]
	\caption{Рекомендуемые значения повышения приоритета}
	\begin{center}
		\begin{tabular}{|p{0.5\textwidth}l|}
			\hline
			Устройство                                                       & Повышение \\ \hline
			Диск, CD-RO M , параллельный порт, видео                         & 1         \\
			Сеть, почтовый слот, именованный канал, последовательный порт    & 2         \\
			Клавиатура, мышь                                                 & 6         \\
			Звуковая карта                                                   & 8    	 \\ \hline    
		\end{tabular}
	\end{center}
	\label{mss}
\end{table}

\subsection{MMCSS}

Потоки, на которых выполняются различные мультимедийные приложения, должны выполняться с минимальными задержками. В Windows эта задача решается путем повышения приоритетов таких потоков драйвером Multi Media Class Scheduler Service --- MMCSS.

MMCSS работает со следующими задачами:
\begin{itemize}
	\item звук;
	\item возможность использования функции записи;
	\item воспроизведение звукового или видео контента;
	\item аудио профессионального качества;
	\item задачи администратора многооконного режима.
\end{itemize}

Одно из наиболее важных свойств для планирования потоков --- категория планирования (Scheduling Category) --- первичный фактор определяющий приоритет потоков, зарегистрированных в MMCSS:

\begin{table}[H]
	\caption{Категории планирования}
	\begin{center}
		\begin{tabular}{|p{0.3\textwidth}|p{0.2\textwidth}|p{0.4\textwidth}|}
			\hline
			Категория & Приоритет & Описание \\ \hline
			High (Высокая)  & 23-26 & Потоки профессионального аудио запущенные с приоритетом выше, чем у других потоков на системе, за исключением критических системных потоков \\
			Medium (Средняя) & 16-22 & Потоки, являющиеся частью приложений первого плана, например Windows Media Player \\
			Low (Низкая) & 8-15 & Все остальные потоки, не являющиеся частью предыдущих категорий \\ 
			Exhausted (Исчерпавшиеся потоки) & 1-7 & Потоки, исчерпавшие свою долю времени центрального процессора, выполнение которых продолжиться, только если не будут готовы к выполнению другие потоки с более высоким уровнем приоритета \\ \hline
		\end{tabular}
	\end{center}
\end{table}

Функции MMCSS временно повышают приоритет потоков, зарегистрированных с MMCS до уровня, соответствующего их категориям планирования. Далее, их приоритет снижается до уровня, соответствующего категории Exhausted, для того чтобы другие потоки могли получить ресурс.

\section{Unix системы}
В данной работе рассмотрен классический UNIX, разработанный в начале 70-х годов. В современных системах могут использоваться различные алгоритмы планирования. 

В системах UNIX ядро использует принцип вытесняемого циклического планирования. Это значит, что процессы, имеющие одинаковые приоритеты, будут выполнятся циклически друг за другом, и каждому из них будет отведен квант времени, обычно равный 100 миллисекундам. Более высокий по приоритету процесс, выполняющийся в режиме ядра, вытеснит более низкий по приоритету процесс  даже если последний не использовал весь отведенный ему квант времени. 
Приоритет процесса определяется фактором <<любезности>> и фактором утилизации. Суперпользователь может повлиять на приоритет процесса, используя системный вызов nice. % Фактор утилизации определяется степенью последней 

Дескриптор процесса pro c содержит следующие поля, которые относятся к приоритету:
\begin{itemize}
	\item \texttt{p\_pri} --- текущий приоритет планирования;
	\item \texttt{p\_usrpri} --- приоритет процесса в режиме задачи;
	\item \texttt{p\_cpu} --- результат последнего измерения степени загруженности процессора;
	\item \texttt{p\_nice} --- фактор любезности.
\end{itemize}
Когда процесс находится в режиме задачи, значения \texttt{p\_pri} и \texttt{p\_usrpri} равны. Значение \texttt{p\_pri} может быть повышено планировщиком для выполнения процесса в режиме ядра, а \texttt{p\_usrpri} будет хранить приоритет, который будет назначен при возвращении в режим задачи. 

Приоритеты ядра фиксированы и зависят от причины засыпания процесса. В таблице \ref{bsd} приведены события и связанные с ними значения приоритета ядра в системе 4.3BSD. 

\begin{table}[H]
	\caption{Таблица приоритетов в системе 4.3BSD}
	\begin{center}
		\begin{tabular}{ |l|l|p{0.6\textwidth}|  }
			\hline
			\textbf{Приоритет} & \textbf{Значение} & \textbf{Описание} \\ \hline
			\texttt{PSWP} & 0 & Свопинг \\
			\texttt{PSWP + 1} & 1 & Страничный демон \\
			\texttt{PSWP + 1/2/4} & 1/2/4 & Другие действия по обработке памяти \\
			\texttt{PINOD} & 10 & Ожидание освобождения inode \\
			\texttt{PRIBIO} & 20 & Ожидание дискового ввода-вывода \\
			\texttt{PRIBIO + 1} & 21 & Ожидание освобождения буфера \\
			\texttt{PZERO} & 25 & Базовый приоритет \\
			\texttt{TTIPRI} & 28 & Ожидание ввода с терминала \\
			\texttt{TTOPRI} & 29 & Ожидание вывода с терминала \\ 
			\texttt{PWAIT} & 30 & Ожидание завершения процесса потомка \\
			\texttt{PLOCK} & 35 & Консультативное ожидание блокированного ресурса \\
			\texttt{PSLEP} & 40 & Ожидание сигнала \\
			\hline
		\end{tabular}
		\label{bsd}
	\end{center}
\end{table}

При инициализации процесса поле \texttt{p\_cpu} равно нулю. На каждом тике обработчик прерывания инициализирует отложенный вы­зов процедуры \texttt{schedcpu()}, которая уменьшает значение \texttt{p\_cpu} каждого процесса
исходя из фактора <<полураспада>>, который рассчитывается по формуле:
\begin{equation}
	decay = \frac{2 \cdot load\_average}{2 \cdot load\_average + 1},
\end{equation}
где $load\_average$ --- среднее количество процессов, находящихся в состоянии готовности к выполнению за последнюю секунду. 
Процедура \texttt{schedcpu()} пересчитывает приоритеты для режима задачи всех процессов следующим образом:
\begin{equation}
	p\_usrpri = PUSER + \frac{p\_cpu}{2} + 2 \cdot p\_nice,
\end{equation}
где \texttt{PUSER} -- базовый приоритет в режиме задачи, который равен 50.

В результате, если процесс до вытеснения другим процессом использовал большое количество процессорного времени, то его \texttt{p\_cpu} будет увеличен. Это приведет к росту значения \texttt{p\_usrpri} и, следовательно, к понижению приоритета. Чем дольше процесс простаивает в очереди на выполнение, тем больше фактор полураспада уменьшает его \texttt{p\_cpu}. Такая схема предотвращает бесконечное откладывание низкоприоритетных процессов. 

\addchap{Вывод}

Обработчик системного таймера в операционных системах Windows и Unox выполняют схожие основные функции -- инициализируют отложенные действия, выполняют декремент различных счетчиков времени.

Пересчет динамических приоритетов пользовательских процессов выполняется для того чтобы исключить их бесконечное откладывание.

Приоритет пользовательского процесса в классическом Unix может динамически пересчитываться, в зависимости от фактора любезности, \texttt{p\_cpu} и базового приоритета, приоритеты ядра являются фиксированными. 

При создании процесса в Windows, ему назначается базовый приоритет. Потоку назначается относительный приоритет согласно соответствующему процессу.
